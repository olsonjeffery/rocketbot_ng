// Generated by CoffeeScript 1.3.3
(function() {
  var logging, models, punish_nick, punish_plugin, punjar_plugin, puns_plugin, punshe_common, shenanigans_plugin, user_data_init, user_data_initialized, _;

  _ = require('underscore');

  logging = require('./logging');

  models = {};

  user_data_initialized = false;

  user_data_init = function(db) {
    user_data_initialized = true;
    models.user_data = db.sequelize.define('user_data', {
      id: {
        type: db.Sql.INTEGER,
        autoIncrement: true,
        allowNull: false
      },
      nick: db.Sql.STRING,
      puns: db.Sql.INTEGER,
      swears: db.Sql.INTEGER,
      weather_loc: db.Sql.STRING
    }, {
      classMethods: {
        by_nick: function(nick, cb) {
          return this.find({
            where: {
              nick: nick
            }
          }).success(function(entry) {
            return cb(entry);
          });
        },
        top_puns: function(cb) {
          return this.findAll({
            limit: 5,
            order: 'puns DESC'
          }).success(function(entries) {
            return cb(entries);
          });
        },
        top_swears: function(cb) {
          return this.findAll({
            limit: 5,
            order: 'swears DESC'
          }).success(function(entries) {
            return cb(entries);
          });
        },
        new_ud: function(nick) {
          return this.build({
            nick: nick,
            puns: 0,
            swears: 0,
            weather_loc: ''
          });
        }
      }
    });
    return models.user_data.sync();
  };

  punish_nick = function(pun_nick, client, reply, frag, is_punish) {
    console.log("in punish_nick()");
    return models.user_data.by_nick(pun_nick, function(ud) {
      var frag_msg;
      console.log("in put by_nick() cb");
      frag_msg = "";
      if (frag != null) {
        frag_msg = "for saying '" + frag + "'.";
      }
      if (ud != null) {

      } else {
        ud = models.user_data.new_ud(pun_nick);
      }
      if (is_punish) {
        ud.puns += 1;
      } else if (ud.puns > 0) {
        ud.puns -= 1;
      }
      ud.save();
      return client.say(reply, ("" + pun_nick + " now owes the pun jar ") + ("$" + ((ud.puns * 0.25).format(2)) + " " + frag_msg + "."));
    });
  };

  punshe_common = function(client, msg, is_punish) {
    var latest_msg, plbl, pun_nick;
    pun_nick = _.first(msg.msg.compact().split(' '));
    if (pun_nick === msg.sending_nick) {
      plbl = is_punish ? "punish" : "un-punish";
      client.say(msg.reply, ("Sorry, you can't " + plbl + " yourself (as much as ") + "you probably deserve it).");
      return null;
    }
    return latest_msg = logging.models.log_entry.latest_entry_for(pun_nick, function(e) {
      var cutoff_time, sentence_frag;
      if (e != null) {
        sentence_frag = _.rest(msg.msg.compact().split(' ')).join(' ').compact();
        if (sentence_frag !== null && sentence_frag.length > 0) {
          cutoff_time = Date.create('2 hours ago');
          console.log(("doing frag check for " + pun_nick + " with ") + ("'" + sentence_frag + "'"));
          return logging.models.log_entry.entries_for_nick_after(pun_nick, cutoff_time, function(entries) {
            var entry;
            console.log("# of entries for user in past 2 hrs: " + ("" + entries.length));
            entries = _.filter(entries, function(e) {
              return e.msg.indexOf(sentence_frag) !== -1;
            });
            console.log("# of frag-match entries: " + ("" + entries.length));
            if ((entries != null) && entries.length > 0) {
              if (entries.length === 1) {
                entry = _.first(entries);
                if (entry.is_pun && is_punish) {
                  return client.say(msg.reply, "Sorry, this comment by " + ("" + pun_nick + " has already been marked as a pun."));
                } else if (!entry.is_pun && !is_punish) {
                  return client.say(msg.reply, "Sorry, this comment by " + ("" + pun_nick + " isn't marked as a pun."));
                } else {
                  entry.is_pun = is_punish ? 1 : 0;
                  entry.save();
                  return punish_nick(pun_nick, client, msg.reply, entry.msg, is_punish);
                }
              } else {
                return client.say(msg.reply, ("Sorry, " + pun_nick + " has said ") + "more than one " + ("thing matching '" + sentence_frag + "' in the past two ") + " hours. Try being more specific.");
              }
            } else {
              return client.say(msg.reply, ("" + pun_nick + " hasn't said anything") + " matching " + ("'" + sentence_frag + "' in the past two hours."));
            }
          });
        } else {
          cutoff_time = Date.create('10 minutes ago');
          if (e.createdAt > cutoff_time) {
            return punish_nick(pun_nick, client, msg.reply, null, is_punish);
          } else {
            return client.say(msg.reply, "Sorry, I can't give an unattributed " + (is_punish ? "punishment " : "un-punishment") + "to someone who hasn't spoken in the last ten minutes.");
          }
        }
      } else {
        return client.say(msg.reply, "I don't even know who " + pun_nick + " is, sorry.");
      }
    });
  };

  punjar_plugin = (function() {

    function punjar_plugin(plg_ldr, options, db) {
      this.db = db;
      if (!user_data_initialized) {
        user_data_init(this.db);
      }
    }

    punjar_plugin.prototype.name = 'punjar';

    punjar_plugin.prototype.msg_type = 'message';

    punjar_plugin.prototype.version = '1';

    punjar_plugin.prototype.commands = ['punjar'];

    punjar_plugin.prototype.match_regex = function() {
      return null;
    };

    punjar_plugin.prototype.process = function(client, msg) {
      if ((msg.msg != null) && msg.msg.length > 0) {
        return models.user_data.by_nick(msg.msg, function(ud) {
          if (ud != null) {
            return client.say(msg.reply, ("" + ud.nick + " owes the pun jar ") + ("$" + ((ud.puns * .25).format(2)) + "."));
          } else {
            return client.say(msg.reply, "Sorry, I got nuthin' for " + msg.msg);
          }
        });
      } else {
        return models.user_data.top_puns(function(entries) {
          var ctr;
          client.say(msg.reply, "Top punsters:");
          ctr = 1;
          return _.each(entries, function(e) {
            client.say(msg.reply, ("" + ctr + ". " + e.nick + " - ") + ("$" + ((e.puns * .25).format(2))));
            return ctr += 1;
          });
        });
      }
    };

    return punjar_plugin;

  })();

  shenanigans_plugin = (function() {

    function shenanigans_plugin(plg_ldr, options, db) {
      this.db = db;
      if (!user_data_initialized) {
        user_data_init(this.db);
      }
    }

    shenanigans_plugin.prototype.name = 'shenanigans';

    shenanigans_plugin.prototype.msg_type = 'message';

    shenanigans_plugin.prototype.version = '1';

    shenanigans_plugin.prototype.commands = ['shenanigans'];

    shenanigans_plugin.prototype.match_regex = function() {
      return null;
    };

    shenanigans_plugin.prototype.process = function(client, msg) {
      return punshe_common(client, msg, false);
    };

    return shenanigans_plugin;

  })();

  puns_plugin = (function() {

    function puns_plugin(plg_ldr, options, db) {
      this.db = db;
      if (!user_data_initialized) {
        user_data_init(this.db);
      }
    }

    puns_plugin.prototype.name = 'recent puns';

    puns_plugin.prototype.msg_type = 'message';

    puns_plugin.prototype.version = '1';

    puns_plugin.prototype.commands = ['puns'];

    puns_plugin.prototype.match_regex = function() {
      return null;
    };

    puns_plugin.prototype.process = function(client, msg) {
      if ((msg.msg != null) && msg.msg.length > 0) {
        return logging.models.log_entry.recent_puns_from(msg.msg, function(entries) {
          if ((entries != null) && entries.length > 0) {
            client.say(msg.reply, "Recent puns from " + msg.msg + ":");
            return _.each(entries, function(e) {
              return client.say(msg.reply, ("" + (e.createdAt.relative()) + " ") + ("\"" + e.msg + "\""));
            });
          } else {
            return client.say(msg.reply, ("No recorded puns logged from " + msg.msg + ",") + " sorry.");
          }
        });
      } else {
        return logging.models.log_entry.recent_puns(function(entries) {
          if ((entries != null) && entries.length > 0) {
            client.say(msg.reply, "Recent puns:");
            return _.each(entries, function(e) {
              return client.say(msg.reply, ("" + (e.createdAt.relative()) + " <" + e.nick + "> ") + ("" + e.msg));
            });
          } else {
            return client.say(msg.reply, "No recorded puns logged, sorry.");
          }
        });
      }
    };

    return puns_plugin;

  })();

  punish_plugin = (function() {

    function punish_plugin(plg_ldr, options, db) {
      this.db = db;
      if (!user_data_initialized) {
        user_data_init(this.db);
      }
    }

    punish_plugin.prototype.name = 'punish';

    punish_plugin.prototype.msg_type = 'message';

    punish_plugin.prototype.version = '1';

    punish_plugin.prototype.commands = ['pun', 'punish'];

    punish_plugin.prototype.match_regex = function() {
      return null;
    };

    punish_plugin.prototype.process = function(client, msg) {
      return punshe_common(client, msg, true);
    };

    return punish_plugin;

  })();

  module.exports = {
    models: models,
    plugins: [punish_plugin, puns_plugin, shenanigans_plugin, punjar_plugin]
  };

}).call(this);
